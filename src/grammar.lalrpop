use std::str::FromStr;
use string_interner::Sym;
use crate::term::*;
use crate::error::{Spanned, Span};

grammar;

pub STerm: Spanned<Term> = Spanned<Term>;

Spanned<T>: Spanned<T> = {
    <l:@L> <t:T> <r:@R> => Spanned::new(t, Span(l, r)),
};

Term: Term = {
    Let,
    Fun,
    <x:Spanned<BelowAnn>> ":" <t:STerm> => Term::Ann(x, t),
    BelowAnn,
};

BelowAnn: Term = {
    Arrow,
    <f:Spanned<Atom>> <x:Spanned<Atom>> => Term::App(f, x),
    Atom,
}

Let: Term = {
    "let" <x:Var> "=" <t:STerm> "in" <u:STerm> => Term::Let(x, t, u),
}

Arrow: Term = {
    "fn" <a:Spanned<Atom>> "->" <b:Spanned<BelowAnn>> => Term::Arrow(a, b),
}

Fun: Term = {
    "fn" <x:Var> "=>" <b:STerm> => Term::Fun(x, b),
}

Atom: Term = {
    "()" => Term::Unit,
    "(" <a:STerm> "," <b:STerm> ")" => Term::Pair(a, b),
    Builtin => Term::Builtin(<>),
    "Type" => Term::Type,
    <i:Int> => Term::I32(i),
    <v:Var> => Term::Var(v),
    "(" <Term> ")",
}

Builtin: Builtin = {
    "Int" => Builtin::Int,
}

Var: Sym = <s:r"[A-Za-z_][A-Za-z_0-9]*"> => INTERN.write().unwrap().get_or_intern(s);
Int: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();
