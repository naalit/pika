use std::str::FromStr;
use crate::common::*;
use crate::term::Builtin;
use crate::error::{Spanned, Span};
use lalrpop_util::ParseError;

grammar;

extern {
    type Error = Spanned<String>;
}

pub STerm: Spanned<ParseTree<'input>> = Spanned<Term>;

Spanned<T>: Spanned<T> = {
    <l:@L> <t:T> <r:@R> => Spanned::new(t, Span(l, r)),
};

Term: ParseTree<'input> = {
    Let,
    Fun,
    The,
    Binder,
    App,
}

App: ParseTree<'input> = {
    <f:Spanned<App>> <x:Spanned<Atom>> => ParseTree::App(f, x),
    Atom,
}

The: ParseTree<'input> = {
    "the" <t:Spanned<Atom>> <u:Spanned<Atom>> => ParseTree::The(t, u),
}

Binder: ParseTree<'input> = {
    <x:Var> ":" <t:STerm?> => ParseTree::Binder(x, t),
}

Let: ParseTree<'input> = {
    "let" <x:Var> "=" <t:STerm> "in" <u:STerm> => ParseTree::Let(x, t, u),
}

Binder2: Option<Spanned<ParseTree<'input>>> = {
    ":" <STerm?>,
}
/// a b c : T --> (a:T) (b:T) (c:T)
MultiBinder: Vec<Spanned<ParseTree<'input>>> = {
    <v:Spanned<Atom>+> <t:Binder2?> =>? if let Some(t) = t {
        let mut r = Vec::new();
        for i in v {
            let span = i.span();
            if let ParseTree::Var(i) = i.force_unwrap() {
                r.push(Spanned::new(ParseTree::Binder(i, t.clone()), span));
            } else {
                return Err(ParseError::User {
                    error: Spanned::new(": can only be used with binders".to_string(), span),
                });
            }
        }
        Ok(r)
    } else {
        Ok(v)
    },
}

SpanToo<T>: (T, Span) = {
    <l:@L> <t:T> <r:@R> => (t, Span(l, r)),
}

Fun: ParseTree<'input> = {
    "fun" <a:MultiBinder> "=>" <b:SpanToo<Term>> => {
        let (b, bs) = b;
        a.into_iter().rfold(b, |b, a| ParseTree::Fun(a, Spanned::new(b, bs)))
    },
}

Atom: ParseTree<'input> = {
    "()" => ParseTree::Unit,
    "(" <a:STerm> "," <b:STerm> ")" => ParseTree::Pair(a, b),
    Builtin => ParseTree::Builtin(<>),
    "Type" => ParseTree::Type,
    Int => ParseTree::I32(<>),
    Var => ParseTree::Var(<>),
    "(" <Term> ")",
}

Builtin: Builtin = {
    "Int" => Builtin::Int,
}

Var: &'input str = r"[A-Za-z_][A-Za-z_0-9]*";
Int: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();
