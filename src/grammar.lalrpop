use crate::common::*;
use crate::term::*;
use crate::binding::{ParseDef, ParseStmt};
use crate::error::{Spanned, Span};
use lalrpop_util::ParseError;
use crate::lexer::Tok;
use either::Either;

grammar<'input>(input: &'input str);

extern {
    type Location = usize;
    type Error = Spanned<crate::lexer::LexError>;

    enum Tok<'input> {
        TYPE => Tok::Type(<u32>),
        "struct" => Tok::Struct,
        "the" => Tok::The,
        "do" => Tok::Do,
        "move" => Tok::Move,
        "of" => Tok::Of,
        "type" => Tok::Data,
        "fun" => Tok::Fun,
        "case" => Tok::Case,
        "raise" => Tok::Raise,
        "catch" => Tok::Catch,
        "with" => Tok::With,
        ":" => Tok::Colon,
        ";" => Tok::Semi,
        "=>" => Tok::Arrow,
        "=" => Tok::Equals,
        "\n" => Tok::Newline,
        "(" => Tok::POpen,
        ")" => Tok::PClose,
        "{" => Tok::BraceOpen,
        "}" => Tok::BraceClose,
        "[" => Tok::BraketOpen,
        "]" => Tok::BraketClose,
        "|" => Tok::Bar,
        "," => Tok::Comma,
        "." => Tok::Dot,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "*" => Tok::Times,
        "/" => Tok::Div,
        INT_LIT => Tok::LitInt(<i32>),
        NAME => Tok::Name(<&'input str>),
        INDENT => Tok::Indent,
        DEDENT => Tok::Dedent,
    }
}

pub Defs: Vec<ParseDef<'input>> = {
    "\n"* <v:(<Def> "\n"+)*> <e:Def?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

// A block beginning with the `Keyword` and then one or more `Inner`s
// Can be in { a; b } form or indented with `\n` as delimiter
IBlock<Keyword, Inner>: Vec<Inner> = {
    Keyword "{" <v:(<Inner> ";")*> <o:Inner?> "}" => if let Some(o) = o {
        let mut v = v;
        v.push(o);
        v
    } else {
        v
    },
    Keyword INDENT <(<Inner> "\n"+)+> DEDENT,
}

Struct: ParseTree<'input> = {
    IBlock<"struct", Def> => ParseTree::Struct(<>.into_iter().map(|ParseDef(name, val)| (name, val)).collect()),
}

Stmt: ParseStmt<'input> = {
    Def => ParseStmt::Def(<>),
    STerm => ParseStmt::Expr(<>),
}

Block: ParseTree<'input> = {
    IBlock<"do", Stmt> => ParseTree::Block(<>),
}

Def: ParseDef<'input> = {
    <a:Spanned<TypeDef>> => {
      if let ParseTree::Data { name, .. } = &*a {
        ParseDef(name.clone(), a)
      } else {
        unreachable!()
      }
    },
    <l:Spanned<Var>> ":" <t:STerm> INDENT "=" <r:STerm> "\n"+ DEDENT => {
        let span = Span(t.span().0, r.span().1);
        ParseDef(l, Spanned::new(ParseTree::The(t, r), span))
    },
    <l:Spanned<Var>> INDENT ":" <t:STerm> "\n"+ "=" <r:STerm> "\n"+ DEDENT => {
        let span = Span(t.span().0, r.span().1);
        ParseDef(l, Spanned::new(ParseTree::The(t, r), span))
    },
    <l:Spanned<Var>> ":" <t:STerm> "=" <r:STerm> => {
        let span = Span(t.span().0, r.span().1);
        ParseDef(l, Spanned::new(ParseTree::The(t, r), span))
    },
    <l:Spanned<Var>> INDENT ":" "=" <r:STerm> "\n"+ DEDENT => ParseDef(l, r),
    <l:Spanned<Var>> ":" "=" <r:STerm> => ParseDef(l, r),
}

STerm: Spanned<ParseTree<'input>> = Spanned<Term>;

#[inline]
Spanned<T>: Spanned<T> = {
    <l:@L> <t:T> <r:@R> => Spanned::new(t, Span(l, r)),
}

Term: ParseTree<'input> = {
    Struct,
    Block,
    Fun,
    CaseOf,
    "the" <t:Spanned<Atom>> <u:Spanned<Atom>> => ParseTree::The(t, u),
    <f:Spanned<App>> <v:("|" <Spanned<App>>)+> => {
      let mut v = v;
      // It's a little out of order, but that shouldn't really matter, and we can fix it later anyway
      v.push(f);
      ParseTree::Union(v)
    },
    Binder,
    // `raise` is an expression, not a statement - `raise : Eff R E -> R`
    // It's like Rust `?`
    "raise" <STerm> => ParseTree::Raise(<>),
    "catch" <STerm> => ParseTree::Catch(<>),

    BinOp<OpAdd>,
    BinOp<OpSub>,
    BinOp<OpMul>,
    BinOp<OpDiv>,

    App,
}

OpAdd: Builtin = "+" => Builtin::Add;
OpSub: Builtin = "-" => Builtin::Sub;
OpMul: Builtin = "*" => Builtin::Mul;
OpDiv: Builtin = "/" => Builtin::Div;

BinOp<Op>: ParseTree<'input> = {
  <lhs:Spanned<BinOp<Op>>> <op:Spanned<Op>> <rhs:Spanned<Atom>> => {
    let op = op.copy_span(ParseTree::Builtin(*op));
    ParseTree::App(lhs.copy_span(ParseTree::App(op, lhs.clone())), rhs)
  },
  <lhs:Spanned<Atom>> <op:Spanned<Op>> <rhs:Spanned<Atom>> => {
    let op = op.copy_span(ParseTree::Builtin(*op));
    ParseTree::App(lhs.copy_span(ParseTree::App(op, lhs.clone())), rhs)
  },
}

App: ParseTree<'input> = {
    <f:Spanned<App>> <x:Spanned<Atom>> => ParseTree::App(f, x),
    Atom,
}

Binder: ParseTree<'input> = {
    <x:Var> ":" <t:STerm?> => ParseTree::Binder(x, t),
}

Cons: (Spanned<&'input str>, Either<Spanned<ParseTree<'input>>, Vec<(bool, Spanned<ParseTree<'input>>)>>) = {
  // Some : fun [a:] a => Option a
  <a:Spanned<Var>> ":" <b:STerm> => (a, Either::Left(b)),
  // Fun Sym (Box Term)
  <a:Spanned<Var>> <b:Icit*> => (a, Either::Right(b)),
  // New struct { a := 3; b := 4 }
  // This is only really needed with structs, other things you just parenthesize
  <a:Spanned<Var>> <b:Spanned<Struct>> => (a, Either::Right(vec![(false, b)])),
}

Case: (Spanned<ParseTree<'input>>, Spanned<ParseTree<'input>>) = {
  <STerm> "=>" <STerm>,
}

CaseOf: ParseTree<'input> = {
  "case" <x:STerm> <v:IBlock<"of", Case>> => ParseTree::CaseOf(x, v),
}

TypeDef: ParseTree<'input> = {
  // type Pair : fun Type => Type of New : fun [a:] a a => Pair a
  "type" <name:Spanned<Var>> <ty:(":" <STerm>)?> "of" <c:Cons> => {
    let ty = ty.unwrap_or_else(|| name.copy_span(ParseTree::Type(0)));
    let (a, b) = c;
    let b = b.map_right(|args| {
      if args.is_empty() {
        return name.copy_span(ParseTree::Var(*name));
      }
      let span = Span(
        args.first().map_or(a.span(), |(_,x)| x.span()).0,
        args.last().map_or(a.span(), |(_,x)| x.span()).1,
      );
      Spanned::new(ParseTree::Fun(false, args, name.copy_span(ParseTree::Var(*name))), span)
    }).into_inner();
    ParseTree::Data {
      name,
      ty,
      cons: vec![(a, b)],
    }
  },
  // type Option : fun Type => Type of { None : fun [a:] => Option a; Some : fun [a:] a => Option a }
  "type" <name:Spanned<Var>> <ty:(":" <STerm>)?> <cons:IBlock<"of", Cons>> => {
    let ty = ty.unwrap_or_else(|| name.copy_span(ParseTree::Type(0)));
    let cons = cons.into_iter().map(|c| {
      let (a, b) = c;
      let b = b.map_right(|args| {
        if args.is_empty() {
          return name.copy_span(ParseTree::Var(*name));
        }
        let span = Span(
          args.first().map_or(a.span(), |(_,x)| x.span()).0,
          args.last().map_or(a.span(), |(_,x)| x.span()).1,
        );
        Spanned::new(ParseTree::Fun(false, args, name.copy_span(ParseTree::Var(*name))), span)
      }).into_inner();
      (a, b)
    }).collect();
    ParseTree::Data {
      name,
      ty,
      cons,
    }
  },
}

Icit: (bool, Spanned<ParseTree<'input>>) = {
  "[" <STerm> "]" => (true, <>),
  Spanned<Atom> => (false, <>),
}

/// a b c : T --> (a:T) (b:T) (c:T)
MultiBinder: Vec<(bool, Spanned<ParseTree<'input>>)> = {
    <v:Icit+> <t:(":" <STerm?>)?> =>? if let Some(t) = t {
        let mut r = Vec::new();
        for (b, i) in v {
            let span = i.span();
            if let ParseTree::Var(i) = i.force_unwrap() {
                r.push((b, Spanned::new(ParseTree::Binder(i, t.clone()), span)));
            } else {
                return Err(ParseError::User {
                    error: Spanned::new(crate::lexer::LexError::Other("':' can only be used with binders".to_string()), span),
                });
            }
        }
        Ok(r)
    } else {
        Ok(v)
    },
}

Fun: ParseTree<'input> = {
  <m:"move"?> "fun" <a:MultiBinder> "=>" <b:Spanned<Term>> => {
    ParseTree::Fun(m.is_some(), a, b)
  },
}

Intersperse<T, Sep>: Vec<T> = {
  T => vec![<>],
  <v:(<T> Sep)+> <l:T?> => if let Some(l) = l {
    let mut v = v;
    v.push(l);
    v
  } else {
    v
  },
}

Atom: ParseTree<'input> = {
    <r:Spanned<Atom>> "." <v:Spanned<Var>> => ParseTree::Project(r, v),
    "(" ")" => ParseTree::Unit,
    "(" <a:STerm> "," <b:STerm> ")" => ParseTree::Pair(a, b),
    TYPE => ParseTree::Type(<>),
    Int => ParseTree::I32(<>),
    Var => ParseTree::Var(<>),
    "(" <Term> ")",
}

Var: &'input str = {
    NAME => &<>,
}
Int: i32 = INT_LIT;
