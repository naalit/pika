use crate::common::*;
use crate::term::*;
use crate::binding::{ParseDef, ParseStmt};
use crate::error::{Spanned, Span};
use lalrpop_util::ParseError;
use crate::lexer::Tok;

grammar<'input>(input: &'input str);

extern {
    type Location = usize;
    type Error = Spanned<crate::lexer::LexError>;

    enum Tok<'input> {
        "fun" => Tok::Fun,
        "Type" => Tok::Type,
        "Int" => Tok::Int,
        "struct" => Tok::Struct,
        "the" => Tok::The,
        "do" => Tok::Do,
        "tag" => Tok::Tag,
        ":" => Tok::Colon,
        ";" => Tok::Semi,
        "=>" => Tok::Arrow,
        "=" => Tok::Equals,
        "\n" => Tok::Newline,
        "(" => Tok::POpen,
        ")" => Tok::PClose,
        "{" => Tok::BraceOpen,
        "}" => Tok::BraceClose,
        "," => Tok::Comma,
        "." => Tok::Dot,
        INT_LIT => Tok::LitInt(<i32>),
        NAME => Tok::Name(<&'input str>),
        INDENT => Tok::Indent,
        DEDENT => Tok::Dedent,
    }
}

Lines<T>: Vec<T> = {
    "\n"* <v:(<T> "\n"+)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

// A block beginning with the `Keyword` and then one or more `Inner`s
// Can be in { a; b } form or indented with `\n` as delimiter
IBlock<Keyword, Inner>: Vec<Inner> = {
    Keyword "{" <v:(<Inner> ";")*> <o:Inner?> "}" => if let Some(o) = o {
        let mut v = v;
        v.push(o);
        v
    } else {
        v
    },
    Keyword "\n" INDENT <(<Inner> "\n"+)+> DEDENT,
}

Struct: ParseTree<'input> = {
    IBlock<"struct", Def> => ParseTree::Struct(<>.into_iter().map(|ParseDef(name, val)| (name, val)).collect()),
}

Stmt: ParseStmt<'input> = {
    Def => ParseStmt::Def(<>),
    STerm => ParseStmt::Expr(<>),
}

Block: ParseTree<'input> = {
    IBlock<"do", Stmt> => ParseTree::Block(<>),
}

pub Defs: Vec<ParseDef<'input>> = Lines<Def>;

Def: ParseDef<'input> = {
    <t:Spanned<"tag">> <v:Spanned<Var>> => {
        let span = Span(t.span().0, v.span().1);
        ParseDef(v.clone(), Spanned::new(ParseTree::Tag(v.force_unwrap()), span))
    },
    <l:Spanned<Var>> ":" <t:STerm> "=" <r:STerm> => {
        let span = Span(t.span().0, r.span().1);
        ParseDef(l, Spanned::new(ParseTree::The(t, r), span))
    },
    <l:Spanned<Var>> ":" "=" <r:STerm> => ParseDef(l, r),
}

NotFun: ParseTree<'input> = {
    The,
    Binder,
    App,
}

STerm: Spanned<ParseTree<'input>> = Spanned<Term>;

#[inline]
Spanned<T>: Spanned<T> = {
    <l:@L> <t:T> <r:@R> => Spanned::new(t, Span(l, r)),
};

Term: ParseTree<'input> = {
    Struct,
    Block,
    Fun,
    The,
    Binder,
    // To allow e.g. (Some x:)
    <f:Spanned<App>> <x:Spanned<Binder>> => ParseTree::App(f, x),
    App,
}

App: ParseTree<'input> = {
    <f:Spanned<App>> <x:Spanned<Atom>> => ParseTree::App(f, x),
    Atom,
}

The: ParseTree<'input> = {
    "the" <t:Spanned<Atom>> <u:Spanned<Atom>> => ParseTree::The(t, u),
}

Binder: ParseTree<'input> = {
    <x:Var> ":" <t:STerm?> => ParseTree::Binder(x, t),
}

Binder2: Option<Spanned<ParseTree<'input>>> = {
    ":" <STerm?>,
}
/// a b c : T --> (a:T) (b:T) (c:T)
MultiBinder: Vec<Spanned<ParseTree<'input>>> = {
    <v:Spanned<Atom>+> <t:Binder2?> =>? if let Some(t) = t {
        let mut r = Vec::new();
        for i in v {
            let span = i.span();
            if let ParseTree::Var(i) = i.force_unwrap() {
                r.push(Spanned::new(ParseTree::Binder(i, t.clone()), span));
            } else {
                return Err(ParseError::User {
                    error: Spanned::new(crate::lexer::LexError::Other(": can only be used with binders".to_string()), span),
                });
            }
        }
        Ok(r)
    } else {
        Ok(v)
    },
}

SpanToo<T>: (T, Span) = {
    <l:@L> <t:T> <r:@R> => (t, Span(l, r)),
}

Fun: ParseTree<'input> = {
    "fun" <a:MultiBinder> "=>" <b:SpanToo<Term>> => {
        let (b, bs) = b;
        a.into_iter().rfold(b, |b, a| ParseTree::Fun(a, Spanned::new(b, bs)))
    },
}

Atom: ParseTree<'input> = {
    <r:Spanned<Atom>> "." <v:Spanned<Var>> => ParseTree::Project(r, v),
    "(" ")" => ParseTree::Unit,
    "(" <a:STerm> "," <b:STerm> ")" => ParseTree::Pair(a, b),
    Builtin => ParseTree::Builtin(<>),
    "Type" => ParseTree::Type,
    Int => ParseTree::I32(<>),
    Var => ParseTree::Var(<>),
    "(" <Term> ")",
}

Builtin: Builtin = {
    "Int" => Builtin::Int,
}

Var: &'input str = {
    NAME => &<>,
}
Int: i32 = INT_LIT;
