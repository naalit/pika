# Custom standard library
type Option a of
    None
    Some a
where
    fun flatten [a] (self : Option (Option a)) : Option a = case self of
        None => None
        Some a => a

type List a of
    Nil
    Cons a (box List a)
where
    fun get [a] (self : List a) (i : I32) : Option a = case self of
        Nil => Option.None
        Cons x xs => if i == 0 then Option.Some x else xs.get (i - 1)

    fun set [a] (self : List a) (i : I32) (new : a) : List a = case self of
        Nil => Nil
        Cons x xs => if i == 0
            then Cons new xs
            else Cons x (xs.set (i - 1) new)

    fun repeat [a] (len : I32) (x : a) : List a = if len == 0
        then List.Nil
        else List.Cons x (repeat (len - 1) x)

    fun len [a] (self : List a) : I32 = case self of
        Nil => 0
        Cons _ rest => 1 + rest.len

type Display a = sig
    val display : a -> () with IO
where
    fun display [a] (self : Display a) (x : a) with IO = case self of
        Display _ r => r.display x

    val ForI32 = Display I32 struct
        val display = print
    val ForString = Display String struct
        val display = puts

    fun ForOption [a] (d : Display a) = Display (Option a) struct
        fun display (x : Option a) with IO = case x of
            Option.None => puts "None"
            Option.Some x => do
                puts "Some "
                d.display x

fun println [a] (d : Display a) (x : a) : () with IO = do
    d.display x
    puts "\n"

# Tic-Tac-Toe
type Player of
    X
    O
where
    val Dsp = Display Player struct
        fun display (x : Player) with IO = case x of
            X => puts "X"
            O => puts "O"

type Board = List (Option Player)
where
    fun map (self : Board) (f : List (Option Player) -> List (Option Player)) : Board = case self of
        Board board => Board (f board)

    fun set (self : Board) (x : I32) (y : I32) (p : Player) : Board = self.map
        board => board.set (x + y * 3) (Option.Some p)

    fun list (self : Board) : List (Option Player) = case self of
        Board board => board

    fun new () : Board =
        Board
            List.repeat 9 (Option.None)

    fun print (self : Board) : () with IO = do
        fun range (a b : I32) (f : I32 -> () with IO) : () with IO = if a >= b
            then ()
            else do
                f a
                range (a + 1) b f

        range 0 3 ((y : I32) => range 0 3 ((x : I32) => do
            if x == 0 then puts "\n" else ()
            val p = self.list.get (x + y * 3)
            case p.flatten of
                Option.None => puts " _"
                Option.Some (Player.X) => puts " X"
                Option.Some (Player.O) => puts " O"
        ))
        puts "\n"

fun main () with IO = do
    val board = Board.new ()
    val board = board.set 0 1 (Player.X)
    val board = board.set 1 1 (Player.O)
    val board = board.set 2 0 (Player.X)
    board.print
