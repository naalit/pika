# This is a more realistic test using coroutines
# It involves changing the effect continuation each time, and should print out 1-6
eff Yield a of
    Y a : ()
end

fun generator () with Yield I32 = do
    # TODO we shouldn't need `the` here
    Yield.Y [I32] 1
    Yield.Y [I32] 3
    Yield.Y [I32] 5
end

type Coroutine a of
    Active a (() -> () with Yield a)
    Done
where
    fun map_val [a] (f : a -> () with IO) (x : Coroutine a) with IO = case x of
        Active x _ => f x
        Done => ()
    end

    fun step [a] (x : Coroutine a): Coroutine a = case x of
        Active x k => catch k () of
            () => Done
            eff (Yield.Y x) k => Active x k
        end
        Done => Done
    end

    fun start [a] (f : () -> () with Yield a): Coroutine a = catch f () of
        () => Done
        eff (Yield.Y x) k => Active x k
    end
end

fun main () with IO = do
    val k = Coroutine.start generator
    print 0
    Coroutine.map_val print k
    val k = Coroutine.step k
    print 2
    Coroutine.map_val print k
    val k = Coroutine.step k
    print 4
    Coroutine.map_val print k
    val k = Coroutine.step k
    print 6
    # This shouldn't print anything, because the coroutine is done
    Coroutine.map_val print k
end