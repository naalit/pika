# This makes sure explicit effect polymorphism works
eff Console of
    Print I32 : ()

fun poly [E] (f : I32 -> () with E) with E = do
    f 3
    f 4

fun handle (f : () -> () with Console) : () with IO = catch f () of
    () => ()
    eff (Console.Print i) k => do
        print i
        k ()

eff Yield a of
    Y a : ()

type Coroutine a of
    Go a (() -> Coroutine a)
    Stop
where
    fun new [a] (gen : () -> () with Yield a) : Coroutine a = catch gen () of
        () => Stop
        eff (Yield.Y x) k => Go x k

    ## Steps the coroutine, and if it yields a value, calls `run` on it. Otherwise it's done, and this function does nothing.
    ## Returns the new coroutine.
    fun step [a] (x : Coroutine a) (run : a -> () with IO) : Coroutine a with IO = case x of
        Stop => Stop
        Go a k => do
            run a
            k ()

# Expected output:
# 1
# 2
# 3
# 4
fun main () with IO = do
    # TODO require less annotations

    # First instantiate it with Console, and print it out
    handle
        () => poly [Console] (i => Console.Print (i - 2))
    # Then make it a coroutine, and print out the resultls again
    val k = Coroutine.new [I32] (() => poly Yield.Y)
    val k = k.step print
    val k = k.step print
    val k = k.step print
