# `Option`, but None needs an explicit argument to have an implicit one
type Option: fun Type => Type of
  None : fun [a:] () => Option a
  Some : fun [a:] a => Option a

# This now works! Note that we don't need the implicit argument on the right hand side
unwrap_or : fun [t:] (Option t) t => t = fun x default: => case x of
  Option.Some a => a
  Option.None () => default

# Unions
# f := fun (Int | ()) => ()
# g := fun (x: Int | ()) => f x

# Booleans
type Bool of
  True
  False

Nat := fun (t:Type) (fun t => t) t => t
zero : Nat = fun t f x: => x
suc : (fun Nat => Nat) = fun n t f x: => f (n t f x)
one := suc zero
two := suc one

is_zero : (fun Nat => Bool) = fun n: => n Bool (fun Bool => Bool.False) Bool.True
is_zero_zero := is_zero zero
is_one_zero := is_zero one

s : Option Int = Option.Some 3
n : Option Int = Option.None ()

# k := g 3

# a := fun ((Int, Int) | Int | ()) => ()
# b := fun x: Int | () => a x

si := Option.Some 3
main : Int = unwrap_or (Option.Some 3) 12
