# `Option`, but without implicits
type Option: fun Type => Type of
  None : fun (a:Type) => Option a
  Some : fun (a:Type) a => Option a

# This now works!
unwrap_or : fun (t:Type) (Option t) t => t = fun _ x default: => case x of
  Option.Some _ a => a
  Option.None _ => default

# Unions
# f := fun (Int | ()) => ()
# g := fun (x: Int | ()) => f x

# Booleans
type Bool of
  True
  False

Nat := fun (t:Type) (fun t => t) t => t
zero : Nat = fun t f x: => x
suc : (fun Nat => Nat) = fun n t f x: => f (n t f x)
one := suc zero
two := suc one

is_zero : (fun Nat => Bool) = fun n: => n Bool (fun Bool => Bool.False) Bool.True
is_zero_zero := is_zero zero
is_one_zero := is_zero one

s : Option Int = Option.Some Int 3
n : Option Int = Option.None Int

# k := g 3

# a := fun ((Int, Int) | Int | ()) => ()
# b := fun x: Int | () => a x

ui := unwrap_or Int
si := Option.Some Int 3
main : Int = unwrap_or Int (Option.Some Int 3) 12
