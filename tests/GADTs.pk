type GADT[t] of
    Two : Type -> GADT[Type]
    One : GADT[()]

# Here Pika needs to figure out that GADT.One is impossible for GADT Type, so this is exhaustive
fun f(x: GADT[Type]): Type = x match
    GADT.Two(t) => t

# Here it needs to figure out that in one branch a is Unit, and in the other it's Type
fun g[a](x: GADT[a]) : a = x match
    GADT.One => ()
    GADT.Two(t) => t

# And finally, here it needs to figure out that the other argument has type Type in one branch
fun h [a] (x: GADT[a], y: ref a) : Type = x match # technically the `ref` isn't needed, because in the only branch where we use it we know it's an immutable type
    GADT.Two(t) => (y -> t)                       # but that's a difficult thing for the compiler to catch; I'm fine with the `ref` being required for now
    GADT.One => Type


type MyGADT[_: Type] of
    Pair[a](MyGADT[a], MyGADT[a]): MyGADT[a]
    Value[a](a): MyGADT[a]
    IsUnit: MyGADT[()]

fun myFun [a] (x: MyGADT[a]): Str = x match
    MyGADT.Pair (MyGADT.IsUnit, MyGADT.Value ()) => "It's (IsUnit, ())!"
    MyGADT.Pair (MyGADT.Value (), MyGADT.IsUnit) => "It's ((), IsUnit)!"
    _ => "It's something else!"


type T of
  A
  B
  C

fun f (x: (T, T)): I32 = x match
  T.A, _ => 12
  _, T.A => 13
  (T.B | T.C), (T.B | T.C) => 42
