# This file is for testing and refining how type errors look.

type MyType has_no_type of
  WrongReturnType : Bool

fun depends_on_error [a] (x : MyType a) = case x of
  # This type error shouldn't actually show up because it depends on WrongReturnType
  WrongReturnType => () + 12

fun inexhaustive (x : Bool) = case x of
  True => False

fun invalid_pat (x : Bool) = case x of
  12 => False

fun invalid_pat_again (x : I32) = case x of
  (y + 2) => False

fun mismatched_case (x : Bool) = case x of
  True => False
  False => Type

let mismatched_if = if True then False else Type
let wrong_if_type = if 3 then 4 else 5
let ambiguous_literal = 12
let not_found = nonexistent
let solution_for_type_not_found = x => x
let solution_for_arg_not_found = do
  fun f [x: Type] (_: I32) = x
  f 12
fun not_type (x : True) = x
let not_function = True False
let wrong_arg_type = True > False
