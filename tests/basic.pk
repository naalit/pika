let AType = Type -> Type
let M : Type -> AType = x y => x
let Z : M Type Type = Type
let Q = Z

let U : Type = Type

fun the (x: Type) (y: x) : x = y

# We can do basic type inference now
let g = the Type Type

# Infering the argument type
fun id_type x : Type = x

# We can now infer the type of this implicit argument
fun id [t] (x: t) = x

# Implicit parameters are passed implicitly
let x = id Type

# Pika is now pretty flexible about newlines, so this works:
# let y : Type -> Type = x => x
let
  y
  : Type -> Type
  =
    x => x

fun local (_:Type) = do
  fun f x = the Type x
  let t = Type -> Type
  f t

@[elaborate]
@[normalize]
let test : [t] t -> t = id id
