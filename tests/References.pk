type DoNotCopy of
    New(I32)

fun copy_ref (x: ref DoNotCopy): (imm DoNotCopy, imm DoNotCopy) = (x, x)
fun move_once (x: own DoNotCopy): DoNotCopy = x
fun reference (x: own DoNotCopy): imm DoNotCopy = x
# fun make_own (x: DoNotCopy): DoNotCopy = x
# fun move_twice (x: own DoNotCopy): (DoNotCopy, DoNotCopy) = (x, x)
# fun in_block (x: own DoNotCopy): (DoNotCopy, DoNotCopy) = do
#     own y = x
#     (y, x)
# fun borrowed (x: own DoNotCopy): (imm DoNotCopy, DoNotCopy) = (x, x)
# fun borrowed2 (x: DoNotCopy): (DoNotCopy, imm DoNotCopy) = (x, x)
# fun borrowed3 (x: own DoNotCopy): () = do
#     let y: imm DoNotCopy = x
#     own z: DoNotCopy = x
#     let w: imm DoNotCopy = y

fun borrow_move(x: DoNotCopy, y: own DoNotCopy): DoNotCopy = y
# fun same_variable(x: own DoNotCopy): DoNotCopy = borrow_move(x, x)
fun shadow(x: DoNotCopy, y: own DoNotCopy): DoNotCopy = do
    own z = y
    borrow_move(x, z)

type Ref[a] of
    Ref(imm a)

fun borrow_move_s(x: Ref[DoNotCopy], y: own DoNotCopy): DoNotCopy = y
fun borrow_move_s2(x: own Ref[DoNotCopy], y: own DoNotCopy): DoNotCopy = y
# fun same_variable_s(x: own DoNotCopy): DoNotCopy = do
#     own r = Ref.Ref(x)
#     borrow_move_s(r, x)
fun shadow_s(x: Ref[DoNotCopy], y: own DoNotCopy): DoNotCopy = do
    own r = Ref.Ref(y)
    own z = y
    borrow_move_s(x, z)
# fun same_variable_s2(x: own DoNotCopy): DoNotCopy = do
#     own r = Ref.Ref(x)
#     borrow_move_s2(r, x)

fun degrade(x: ref mut DoNotCopy): imm DoNotCopy = x
# fun upgrade(x: DoNotCopy): mut DoNotCopy = x
fun make_mut(x: own DoNotCopy): mut DoNotCopy = x
fun borrow_r(x: own DoNotCopy): (imm DoNotCopy, imm DoNotCopy) = (x, x)
# fun borrow_m(x: own DoNotCopy): (mut DoNotCopy, mut DoNotCopy) = (x, x)
# fun borrow_c(x: own DoNotCopy): (mut DoNotCopy, imm DoNotCopy) = (x, x)
# fun borrow_d(x: own DoNotCopy): (imm DoNotCopy, mut DoNotCopy) = (x, x)

fun copy(mut x: I32): I32 = do
    let y: I32 = x
    mut z: I32 = x
    y

# fun assign_imm(x: I32): () = x = 3
fun assign_var(mut x: I32, mut y: I32): I32 = do
    let a: I32 = 3
    mut b = 4
    b = a
    x = 6
    y = x
    y

fun leaser(x: ref mut I32): mut I32 = x
fun lease(x: ref mut I32): mut I32 = do
    leaser(x)
    x
# fun lease_err(x: mut I32): mut I32 = do
#     mut y = leaser(x)
#     leaser(x)
#     y

# fun magic1(x: mut DoNotCopy, y: mut DoNotCopy): () = () # theoretically this could put (mutable) references in y into x
# fun magic2(x: mut DoNotCopy, y: own DoNotCopy): mut DoNotCopy = do
#     magic1(x, y) # now y could be mutably borrowed
#     borrow_move(x, y) # so this should be illegal
#     x

# Merging reference invalidations across match branches
fun move(x: own DoNotCopy): () = ()
fun borrow(x: DoNotCopy): () = ()
fun mutate(x: mut DoNotCopy): () = ()
fun good(a: I32, x: own DoNotCopy): () = a match
    1 => move(x)
    _ => move(x) # fine, the other move was in another branch
# fun bad(a: I32, x: own DoNotCopy) = do
#     a match
#         0 => ()
#         1 => move(x)
#         _ => ()
#     move(x) # not allowed, x may have been moved
# fun bad2(a: I32, x: own DoNotCopy, y: own DoNotCopy): imm DoNotCopy = do
#     let q: imm DoNotCopy = a match
#         0 => y
#         _ => x
#     move(x) # whether this moves x or y, it invalidates q either way
#     q
type Cow[a] of
    Own(a)
    Borrow(imm a)
# fun bad3(a: I32, x: own DoNotCopy): Cow[DoNotCopy] = do
#     own q = a match
#         0 => Cow.Own(x)
#         _ => Cow.Borrow(x)
#     borrow(x) # not allowed, x might be moved
#     q

fun h_own(f: () -> ()) = ()
fun h_ref(f: () imm -> ()) = ()
fun h_mut(f: () mut -> ()) = ()

fun test(f: () mut -> ()): () = do
    f()
    f()
    h_own(() => f())
    h_mut(() => f())
    h_mut(f)
    h_own(f)

# Just here to verify that do-lambda syntax works properly
fun takes_fun(f: (I32, I32) -> I32): I32 = f(1, 2)
fun takes_fun2(a: I32, b: I32, f: (I32, I32) -> I32): I32 = f(a, b)
fun test1(): I32 = takes_fun do a, b =>
    let a2 = a*a
    let b2 = b*b
    a2*a2 + b2*b2
fun test2(): I32 = takes_fun2(1, 2) do a, b =>
    let a2 = a*a
    let b2 = b*b
    a2*a2 + b2*b2

# tests for new rules about closures returning borrows from their environment
fun return_borrow3(x: ref mut DoNotCopy): () mut -> imm DoNotCopy = () => x

type Loop[R, C] of
    Continue(C)
    Break(R)
fun loop[R, C](start: own C, iter: own C mut -> Loop[R, C]): R = iter(start) match
    Loop.Continue(own x) => loop(x, iter)
    Loop.Break(own x) => x

# tests for ownership semantics of pi-types
# borrowing parameters is allowed in pi types
fun calc_type_borrow(x: DoNotCopy): Type = I32
fun p1_good(x: own DoNotCopy): calc_type_borrow(x) = 3

# same with captures
fun p4_good(x: own DoNotCopy): Type = () -> calc_type_borrow(x)

fun magic1(x: mut DoNotCopy, y: mut DoNotCopy): () = () # y cannot escape
fun magic2(x: ref mut DoNotCopy, mut y: own DoNotCopy): mut DoNotCopy = do
    magic1(x, y) # so now y is *not* borrowed
    borrow_move(x, y) # and this is fine
    x
fun magic3(x: ref mut DoNotCopy, mut y: own DoNotCopy): () = do
    magic1(x, y)
    move(y)
    borrow(x)

type X struct
    a: own DoNotCopy
    b: own DoNotCopy
fun separate(x: own X): (DoNotCopy, DoNotCopy) = (x.a, x.b)

fun mut_two(x: mut X) = do
    mut y = x.b
    mutate(x.a)
    mutate(y)

type Y struct
    x: own X
    t: own DoNotCopy
fun y_test(y: own Y) = do
    mut x = y.x
    mutate(y.t)
    mutate(x.a)
    mutate(y.x.a) # `x` is no longer live
    mutate(y.t)
